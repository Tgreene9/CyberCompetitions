# CTF Writeup: NCL Spring 2023 Individual Game

## Challenge Name: AES (Hard) ! Unsolved

### Challenge Description:

One of our security engineers claimed to have developed the world's most advanced encryption scheme using the memfrob function and even open sourced the code! Can you break the code and get the flag from the remote server? The same program is running on the machine's port 1337.

```
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <err.h>

void init(){
    setvbuf(stdout, NULL , _IONBF , 0);
    setvbuf(stderr, NULL , _IONBF , 0);
    setvbuf(stdin, NULL , _IONBF , 0);
}

int main(void){
    init();
    char buf[64];
    puts("Enter string to be encrypted: ");
    ssize_t bytes = read(0, buf, 0x100);
    if(bytes < 0){
        errx(1, "read error");
    }
    memfrob(buf,bytes);
    printf("Frobnicated Data: %s\n",buf);
    return 0;
}

```

### Challenge Questions:

1. What is the flag on the server?


### Solution:



#### Step 1: Identify the format of the document information



#### Step 2: Use a decoder to decode the document information



#### Step 3: Provide answers to the challenge questions

#### Final Answer




## Conclusion:

## Excerpts from Methodologies and techhniques used from NCL Discord
`Stack BOF right? didn't get to this one did yall use msfvenom for shellcode?`
`basic stack buffer overflow`
`No need for shellcode, this was a ret2libc challenge. The only catch being that there's the memfrob function. It just xor's your data by 42 :)`
`really just use pwnlib + xor 42 on whatever you send as result`
`Stack buffer overwrite but it has the binary has the NX bit set, so no stack execution. Which means return2libc`
`Damn. So I had to XOR the ROP chain by 42`
`This challenge was great.  For those wanting to get a start in binex I highly recommend CryptoCat's YouTube videos: https://www.youtube.com/playlist?list=PLHUKi1UlEgOIc07Rfk2Jgb5fZbxDPec94`

Creator
```
If you want to learn more about this style of challenge please read this blog. It's essentially the same type of challenge. You'll see it called ret2libc/ret2puts/ret2plt, etc. https://ir0nstone.gitbook.io/notes/types/stack/aslr/ret2plt-aslr-bypass

To break it down in high level terms:
1) Overflow buffer and jump to a rop chain that leaks an address in the global offset table: You have to keep in mind x64 calling conventions such as which registers things should be in when a function is called(i.e. rdi, rsi, rdx, rcx..)
2) From there you can leak several addresses to determine the libc(it was not provided) or figure out which one is being used on the machine where it was compiled. Keep in mind, LIBC_BASE = Leak - Relative offset. You would have to find the relative offset by looking at the specific libc to find the functions address you leaked
3) After that, you can either use one gadget or call system("/bin/sh") in a similar fashion, using ROP.
4) probably account for stack alignment because pwn is stupid
5) profit

The only difference this challenge had from what I had above is that the function memfrob is called on your input, so you have to figure out what that does(hint: it just xors every byte by 42) and then reverse the process.

I skipped a bunch of nitty gritty details, but there's much better guides on the topic online and in the article I posted. If you have any questions about this or similar types of challenges do feel free to post here or dm. :) 
```

`https://www.youtube.com/watch?v=TTCz3kMutSs

This is also a great video if you are new to ret2libc, as the attack is nearly identical to this, minus the memfrob requiring an extra step`

```
Here's an example of how I'm using pwntools to generate the "first" ropchain
 24 # phase 1
 25 rop = ROP(elf)
 26 rop.call('puts', [elf.got.puts])
 27 rop.call('main')
 28 log.info("Phase1 ROP Chain:\n{}".format(rop.dump()))
 29 
 30 phase1 = [
 31     b'A'*overflow_offset,
 32     rop.chain()
 33 ]
 ```

 `eep in mind w/ challenges like these you can always ROP back to main and re-exploit the same bug to perform more leaks/writes/reads etc`